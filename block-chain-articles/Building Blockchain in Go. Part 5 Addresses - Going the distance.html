<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta name="generator" content="Hugo 0.97.3">

  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="Ivan Kuznetsov">
  <meta property="og:url" content="https://jeiwan.net/posts/building-blockchain-in-go-part-5/">

  <title>Building Blockchain in Go. Part 5: Addresses - Going the distance</title>
  <meta property="og:title" content="Building Blockchain in Go. Part 5: Addresses - Going the distance">
  <meta property="og:type" content="article">
  <meta name="description" content="A blog about blockchains and smart contracts development">
  <meta name="keywords" content="bitcoin, ethereum, evm, smart contract, blockchain, programming, development, solidity, vyper">

  <link rel="stylesheet" href="Building%20Blockchain%20in%20Go.%20Part%205%20Addresses%20-%20Going%20the%20distance_files/css.css">
  <link rel="stylesheet" href="Building%20Blockchain%20in%20Go.%20Part%205%20Addresses%20-%20Going%20the%20distance_files/prism.css">
  <link rel="stylesheet" href="Building%20Blockchain%20in%20Go.%20Part%205%20Addresses%20-%20Going%20the%20distance_files/journal.css">
  <link href="https://jeiwan.net/index.xml" rel="alternate" type="application/rss+xml" title="Going the distance">

  

  

</head>

<body>
  <div class="container">

    <nav class="site-nav">
      <a href="https://jeiwan.net/">Index</a>
    </nav>


<article class="post">
  <header class="post-header">
    <h1 class="post-title">Building Blockchain in Go. Part 5: Addresses</h1>
    <time class="post-date" datetime=" 2017-09-11 11:20:43 +07">11 Sep 2017</time>
  </header>

  <blockquote>
<p>Chinese translations: <a href="https://github.com/liuchengxu/blockchain-tutorial/blob/master/content/part-5/address.md">by liuchengxu</a>, <a href="https://zhangli1.gitbooks.io/dummies-for-blockchain/content/">by zhangli1</a></p>
</blockquote>
<h2 id="introduction">Introduction</h2>
<p>In <a href="https://jeiwan.net/posts/building-blockchain-in-go-part-4/">the previous article</a>,
 we started implementing transactions. You were also introduced to the 
impersonal nature of transactions: there are no user accounts, your 
personal data (e.g., name, passport number or SSN) is not required and 
not stored anywhere in Bitcoin. But there still must be something that 
identifies you as the owner of transaction outputs (i.e. the owner of 
coins locked on these outputs). And this is what Bitcoin addresses are 
needed for. So far we’ve used arbitrary user defined strings as 
addresses, and the time has come to implement real addresses, as they’re
 implemented in Bitcoin.</p>
<blockquote>
<p>This part introduces significant code changes, so it makes no sense explaining all of them here. Please refer to <a href="https://github.com/Jeiwan/blockchain_go/compare/part_4...part_5#files_bucket">this page</a> to see all the changes since the last article.</p>
</blockquote>
<h2 id="bitcoin-address">Bitcoin Address</h2>
<p>Here’s an example of a Bitcoin address: <a href="https://blockchain.info/address/1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa">1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa</a>.
 This is the very first Bitcoin address, which allegedly belongs to 
Satoshi Nakamoto. Bitcoin addresses are public. If you want to send 
coins to someone, you need to know their address. But addresses (despite
 being unique) are not something that identifies you as the owner of a 
“wallet”. In fact, such addresses are a human readable representation of
 public keys. In Bitcoin, your identity is a pair (or pairs) of private 
and public keys stored on your computer (or stored in some other place 
you have access to). Bitcoin relies on a combination of cryptography 
algorithms to create these keys, and guarantee that no one else in the 
world can access your coins without getting physical access to your 
keys. Let’s discuss what these algorithms are.</p>
<h2 id="public-key-cryptography">Public-key Cryptography</h2>
<p>Public-key cryptography algorithms use pairs of keys: public keys and
 private keys. Public keys are not sensitive and can be disclosed to 
anyone. In contrast, private keys shouldn’t be disclosed: no one but the
 owner should have access to them because it’s private keys that serve 
as the identifier of the owner. You are your private keys (in the world 
of cryptocurrencies, of course).</p>
<p>In essence, a Bitcoin wallet is just a pair of such keys. When you 
install a wallet application or use a Bitcoin client to generate a new 
address, a pair of keys is generated for you. The one who controls the 
private key controls all the coins sent to this key in Bitcoin.</p>
<p>Private and public keys are just random sequences of bytes, thus they
 cannot be printed on the screen and read by a human. That’s why Bitcoin
 uses an algorithm to convert public keys into a human readable string.</p>
<blockquote>
<p>If you’ve ever used a Bitcoin wallet application, it’s likely that a 
mnemonic pass phrase was generated for you. Such phrases are used 
instead of private keys and can be used to generate them. This mechanism
 is implemented in <a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">BIP-039</a>.</p>
</blockquote>
<p>Ok, we now know what identifies users in Bitcoin. But how does 
Bitcoin check the ownership of transaction outputs (and coins stored on 
them)?</p>
<h2 id="digital-signatures">Digital Signatures</h2>
<p>In mathematics and cryptography, there’s a concept of digital signature – algorithms that guarantee:</p>
<ol>
<li>that data wasn’t modified while being transferred from a sender to a recipient;</li>
<li>that data was created by a certain sender;</li>
<li>that the sender cannot deny sending the data.</li>
</ol>
<p>By applying a signing algorithm to data (i.e., signing the data), one
 gets a signature, which can later be verified. Digital signing happens 
with the usage of a private key, and verification requires a public key.</p>
<p>In order to sign data we need the following things:</p>
<ol>
<li>data to sign;</li>
<li>private key.</li>
</ol>
<p>The operation of signing produces a signature, which is stored in 
transaction inputs. In order to verify a signature, the following is 
required:</p>
<ol>
<li>data that was signed;</li>
<li>the signature;</li>
<li>public key.</li>
</ol>
<p>In simple terms, the verification process can be described as: check 
that this signature was obtained from this data with a private key used 
to generate the public key.</p>
<blockquote>
<p>Digital signatures are not encryption, you cannot reconstruct the 
data from a signature. This is similar to hashing: you run data through a
 hashing algorithm and get a unique representation of the data. The 
difference between signatures and hashes is key pairs: they make 
signature verification possible.<br>
But key pairs can also be used to encrypt data: a private key is used to
 encrypt, and a public key is used to decrypt the data. Bitcoin doesn’t 
use encryption algorithms though.</p>
</blockquote>
<p>Every transaction input in Bitcoin is signed by the one who created 
the transaction. Every transaction in Bitcoin must be verified before 
being put in a block. Verification means (besides other procedures):</p>
<ol>
<li>Checking that inputs have permission to use outputs from previous transactions.</li>
<li>Checking that the transaction signature is correct.</li>
</ol>
<p>Schematically, the process of signing data and verifying signature looks likes this:</p>
<p><img src="Building%20Blockchain%20in%20Go.%20Part%205%20Addresses%20-%20Going%20the%20distance_files/signing-scheme.png" alt="Digital Signatures"></p>
<p>Let’s now review the full lifecycle of a transaction:</p>
<ol>
<li>In the beginning, there’s the genesis block that contains a coinbase
 transaction. There are no real inputs in coinbase transactions, so 
signing is not necessary. The output of the coinbase transaction 
contains a hashed public key (<code>RIPEMD16(SHA256(PubKey))</code> algorithms are used).</li>
<li>When one sends coins, a transaction is created. Inputs of the 
transaction will reference outputs from previous transaction(s). Every 
input will store a public key (not hashed) and a signature of the whole 
transaction.</li>
<li>Other nodes in the Bitcoin network that receive the transaction will
 verify it. Besides other things, they will check that: the hash of the 
public key in an input matches the hash of the referenced output (this 
ensures that the sender spends only coins belonging to them); the 
signature is correct (this ensures that the transaction is created by 
the real owner of the coins).</li>
<li>When a miner node is ready to mine a new block, it’ll put the transaction in a block and start mining it.</li>
<li>When the blocked is mined, every other node in the network receives a
 message saying the block is mined and adds the block to the blockchain.</li>
<li>After a block is added to the blockchain, the transaction is completed, its outputs can be referenced in new transactions.</li>
</ol>
<h2 id="elliptic-curve-cryptography">Elliptic Curve Cryptography</h2>
<p>As described above, public and private keys are sequences of random 
bytes. Since it’s private keys that are used to identify owners of 
coins, there’s a required condition: the randomness algorithm must 
produce truly random bytes. We don’t want to accidentally generate a 
private key that’s owned by someone else.</p>
<p>Bitcoin uses elliptic curves to generate private keys. Elliptic 
curves is a complex mathematical concept, which we’re not going to 
explain in details here (if you’re curious, check out <a href="http://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">this gentle introduction to elliptic curves</a>
 WARNING: Math formulas!). What we need to know is that these curves can
 be used to generate really big and random numbers. The curve used by 
Bitcoin can randomly pick a number between 0 and 2²⁵⁶ (which is 
approximately 10⁷⁷, when there are between 10⁷⁸ and 10⁸² atoms in the 
visible universe). Such a huge upper limit means that it’s almost 
impossible to generate the same private key twice.</p>
<p>Also, Bitcoin uses (and we will) ECDSA (Elliptic Curve Digital Signature Algorithm) algorithm to sign transactions.</p>
<h2 id="base58">Base58</h2>
<p>Now let’s get back to the above mentioned Bitcoin address: 
1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa. Now we know that this is a 
human-readable representation of a public key. And if we decode it, 
here’s what the public key looks like (as a sequence of bytes written in
 the hexadecimal system):</p>
<div class="highlight"><pre tabindex="0" class="chroma language-shell"><code class=" language-shell" data-lang="shell">0062E907B15CBF27D5425399EBF6F0FB50EBB88F18C29B7D93
</code></pre></div><p>Bitcoin uses the Base58 algorithm to convert 
public keys into human readable format. The algorithm is very similar to
 famous Base64, but it uses shorter alphabet: some letters were removed 
from the alphabet to avoid some attacks that use letters similarity. 
Thus, there are no these symbols: 0 (zero), O (capital o), I (capital 
i), l (lowercase L), because they look similar. Also, there are no + and
 / symbols.</p>
<p>Let’s schematically visualize the process of getting an address from a public key:</p>
<p><img src="Building%20Blockchain%20in%20Go.%20Part%205%20Addresses%20-%20Going%20the%20distance_files/address-generation-scheme.png" alt="Address Generation"></p>
<p>Thus, the above mentioned decoded public key consists of three parts:</p>
<div class="highlight"><pre tabindex="0" class="chroma language-shell"><code class=" language-shell" data-lang="shell">Version  Public key <span class="token builtin class-name">hash</span>                           Checksum
00       62E907B15CBF27D5425399EBF6F0FB50EBB88F18  C29B7D93
</code></pre></div><p>Since hashing functions are one way (i.e., they 
cannot be reversed), it’s not possible to extract the public key from 
the hash. But we can check if a public  key was used to get the hash by 
running it thought the save hash functions and comparing the hashes.</p>
<p>Ok, now that we have all the pieces, let’s write some code. Some of the concepts should be more clear when written in code.</p>
<h2 id="implementing-addresses">Implementing Addresses</h2>
<p>We’ll start with the <code>Wallet</code> structure:</p>
<div class="highlight"><pre tabindex="0" class="chroma language-go"><code class=" language-go" data-lang="go"><span class="token keyword">type</span> Wallet <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	PrivateKey ecdsa<span class="token punctuation">.</span>PrivateKey
	PublicKey  <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Wallets <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	Wallets <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">*</span>Wallet
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">NewWallet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>Wallet <span class="token punctuation">{</span>
	private<span class="token punctuation">,</span> public <span class="token operator">:=</span> <span class="token function">newKeyPair</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	wallet <span class="token operator">:=</span> Wallet<span class="token punctuation">{</span>private<span class="token punctuation">,</span> public<span class="token punctuation">}</span>

	<span class="token keyword">return</span> <span class="token operator">&amp;</span>wallet
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">newKeyPair</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>ecdsa<span class="token punctuation">.</span>PrivateKey<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	curve <span class="token operator">:=</span> elliptic<span class="token punctuation">.</span><span class="token function">P256</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	private<span class="token punctuation">,</span> err <span class="token operator">:=</span> ecdsa<span class="token punctuation">.</span><span class="token function">GenerateKey</span><span class="token punctuation">(</span>curve<span class="token punctuation">,</span> rand<span class="token punctuation">.</span>Reader<span class="token punctuation">)</span>
	pubKey <span class="token operator">:=</span> <span class="token function">append</span><span class="token punctuation">(</span>private<span class="token punctuation">.</span>PublicKey<span class="token punctuation">.</span>X<span class="token punctuation">.</span><span class="token function">Bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> private<span class="token punctuation">.</span>PublicKey<span class="token punctuation">.</span>Y<span class="token punctuation">.</span><span class="token function">Bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">)</span>

	<span class="token keyword">return</span> <span class="token operator">*</span>private<span class="token punctuation">,</span> pubKey
<span class="token punctuation">}</span>
</code></pre></div><p>A wallet is nothing but a key pair. We’ll also need the <code>Wallets</code> type to keep a collection of wallets, save them to a file, and load them from it. In the construction function of <code>Wallet</code> a new key pair is generated. The <code>newKeyPair</code>
 function is straightforward: ECDSA is based on elliptic curves, so we 
need one. Next, a private key is generated using the curve, and a public
 key is generated from the private key. One thing to notice: in elliptic
 curve based algorithms, public keys are points on a curve. Thus, a 
public key is a combination of X, Y coordinates. In Bitcoin, these 
coordinates are concatenated and form a public key.</p>
<p>Now, let’s generate an address:</p>
<div class="highlight"><pre tabindex="0" class="chroma language-go"><code class=" language-go" data-lang="go"><span class="token keyword">func</span> <span class="token punctuation">(</span>w Wallet<span class="token punctuation">)</span> <span class="token function">GetAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span> <span class="token punctuation">{</span>
	pubKeyHash <span class="token operator">:=</span> <span class="token function">HashPubKey</span><span class="token punctuation">(</span>w<span class="token punctuation">.</span>PublicKey<span class="token punctuation">)</span>

	versionedPayload <span class="token operator">:=</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">{</span>version<span class="token punctuation">}</span><span class="token punctuation">,</span> pubKeyHash<span class="token operator">...</span><span class="token punctuation">)</span>
	checksum <span class="token operator">:=</span> <span class="token function">checksum</span><span class="token punctuation">(</span>versionedPayload<span class="token punctuation">)</span>

	fullPayload <span class="token operator">:=</span> <span class="token function">append</span><span class="token punctuation">(</span>versionedPayload<span class="token punctuation">,</span> checksum<span class="token operator">...</span><span class="token punctuation">)</span>
	address <span class="token operator">:=</span> <span class="token function">Base58Encode</span><span class="token punctuation">(</span>fullPayload<span class="token punctuation">)</span>

	<span class="token keyword">return</span> address
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">HashPubKey</span><span class="token punctuation">(</span>pubKey <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span> <span class="token punctuation">{</span>
	publicSHA256 <span class="token operator">:=</span> sha256<span class="token punctuation">.</span><span class="token function">Sum256</span><span class="token punctuation">(</span>pubKey<span class="token punctuation">)</span>

	RIPEMD160Hasher <span class="token operator">:=</span> ripemd160<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> RIPEMD160Hasher<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>publicSHA256<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
	publicRIPEMD160 <span class="token operator">:=</span> RIPEMD160Hasher<span class="token punctuation">.</span><span class="token function">Sum</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span>

	<span class="token keyword">return</span> publicRIPEMD160
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">checksum</span><span class="token punctuation">(</span>payload <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span> <span class="token punctuation">{</span>
	firstSHA <span class="token operator">:=</span> sha256<span class="token punctuation">.</span><span class="token function">Sum256</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
	secondSHA <span class="token operator">:=</span> sha256<span class="token punctuation">.</span><span class="token function">Sum256</span><span class="token punctuation">(</span>firstSHA<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

	<span class="token keyword">return</span> secondSHA<span class="token punctuation">[</span><span class="token punctuation">:</span>addressChecksumLen<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Here are the steps to convert a public key into a Base58 address:</p>
<ol>
<li>Take the public key and hash it twice with <code>RIPEMD160(SHA256(PubKey))</code> hashing algorithms.</li>
<li>Prepend the version of the address generation algorithm to the hash.</li>
<li>Calculate the checksum by hashing the result of step 2 with <code>SHA256(SHA256(payload))</code>. The checksum is the first four bytes of the resulted hash.</li>
<li>Append the checksum to the <code>version+PubKeyHash</code> combination.</li>
<li>Encode the <code>version+PubKeyHash+checksum</code> combination with Base58.</li>
</ol>
<p>As a result, you’ll get a <strong>real Bitcoin address</strong>, you can even check its balance on <a href="https://blockchain.info/">blockchain.info</a>.
 But I can assure you that the balance is 0 no matter how many times you
 generate a new address and check its balance. This is why choosing 
proper public-key cryptography algorithm is so crucial: considering 
private keys are random numbers, the chance of generating the same 
number must be as low as possible. Ideally, it must be as low as 
“never”.</p>
<p>Also, pay attention that you don’t need to connect to a Bitcoin node 
to get an address. The address generation algorithm utilizes a 
combination of open algorithms that are implemented in many programming 
languages and libraries.</p>
<p>Now we need to modify inputs and outputs for them to use addresses:</p>
<div class="highlight"><pre tabindex="0" class="chroma language-go"><code class=" language-go" data-lang="go"><span class="token keyword">type</span> TXInput <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	Txid      <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
	Vout      <span class="token builtin">int</span>
	Signature <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
	PubKey    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>in <span class="token operator">*</span>TXInput<span class="token punctuation">)</span> <span class="token function">UsesKey</span><span class="token punctuation">(</span>pubKeyHash <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
	lockingHash <span class="token operator">:=</span> <span class="token function">HashPubKey</span><span class="token punctuation">(</span>in<span class="token punctuation">.</span>PubKey<span class="token punctuation">)</span>

	<span class="token keyword">return</span> bytes<span class="token punctuation">.</span><span class="token function">Compare</span><span class="token punctuation">(</span>lockingHash<span class="token punctuation">,</span> pubKeyHash<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> TXOutput <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	Value      <span class="token builtin">int</span>
	PubKeyHash <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>out <span class="token operator">*</span>TXOutput<span class="token punctuation">)</span> <span class="token function">Lock</span><span class="token punctuation">(</span>address <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	pubKeyHash <span class="token operator">:=</span> <span class="token function">Base58Decode</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span>
	pubKeyHash <span class="token operator">=</span> pubKeyHash<span class="token punctuation">[</span><span class="token number">1</span> <span class="token punctuation">:</span> <span class="token function">len</span><span class="token punctuation">(</span>pubKeyHash<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">]</span>
	out<span class="token punctuation">.</span>PubKeyHash <span class="token operator">=</span> pubKeyHash
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>out <span class="token operator">*</span>TXOutput<span class="token punctuation">)</span> <span class="token function">IsLockedWithKey</span><span class="token punctuation">(</span>pubKeyHash <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> bytes<span class="token punctuation">.</span><span class="token function">Compare</span><span class="token punctuation">(</span>out<span class="token punctuation">.</span>PubKeyHash<span class="token punctuation">,</span> pubKeyHash<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Notice, that we’re no longer using <code>ScriptPubKey</code> and <code>ScriptSig</code> fields, because we’re not going to implement a scripting language. Instead, <code>ScriptSig</code> is split into <code>Signature</code> and <code>PubKey</code> fields, and <code>ScriptPubKey</code> is renamed to <code>PubKeyHash</code>.
 We’ll implement the same outputs locking/unlocking and inputs signing 
logics as in Bitcoin, but we’ll do this in methods instead.</p>
<p>The <code>UsesKey</code> method checks that an input uses a specific 
key to unlock an output. Notice that inputs store raw public keys (i.e.,
 not hashed), but the function takes a hashed one. <code>IsLockedWithKey</code> checks if provided public key hash was used to lock the output. This is a complementary function to <code>UsesKey</code>, and they’re both used in <code>FindUnspentTransactions</code> to build connections between transactions.</p>
<p><code>Lock</code> simply locks an output. When we send coins to 
someone, we know only their address, thus the function takes an address 
as the only argument. The address is then decoded and the public key 
hash is extracted from it and saved in the <code>PubKeyHash</code> field.</p>
<p>Now, let’s check that everything works correctly:</p>
<div class="highlight"><pre tabindex="0" class="chroma language-shell"><code class=" language-shell" data-lang="shell">$ blockchain_go createwallet
Your new address: 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt

$ blockchain_go createwallet
Your new address: 15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h

$ blockchain_go createwallet
Your new address: 1Lhqun1E9zZZhodiTqxfPQBcwr1CVDV2sy

$ blockchain_go createblockchain -address 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt
0000005420fbfdafa00c093f56e033903ba43599fa7cd9df40458e373eee724d

Done<span class="token operator">!</span>

$ blockchain_go getbalance -address 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt
Balance of <span class="token string">'13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt'</span><span class="token builtin class-name">:</span> <span class="token number">10</span>

$ blockchain_go send -from 15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h -to 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt -amount <span class="token number">5</span>
<span class="token number">2017</span>/09/12 <span class="token number">13</span>:08:56 ERROR: Not enough funds

$ blockchain_go send -from 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt -to 15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h -amount <span class="token number">6</span>
00000019afa909094193f64ca06e9039849709f5948fbac56cae7b1b8f0ff162

Success<span class="token operator">!</span>

$ blockchain_go getbalance -address 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt
Balance of <span class="token string">'13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt'</span><span class="token builtin class-name">:</span> <span class="token number">4</span>

$ blockchain_go getbalance -address 15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h
Balance of <span class="token string">'15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h'</span><span class="token builtin class-name">:</span> <span class="token number">6</span>

$ blockchain_go getbalance -address 1Lhqun1E9zZZhodiTqxfPQBcwr1CVDV2sy
Balance of <span class="token string">'1Lhqun1E9zZZhodiTqxfPQBcwr1CVDV2sy'</span><span class="token builtin class-name">:</span> <span class="token number">0</span>
</code></pre></div><p>Nice! Now let’s implement transaction signatures.</p>
<h2 id="implementing-signatures">Implementing Signatures</h2>
<p>Transactions must be signed because this is the only way in Bitcoin 
to guarantee that one cannot spend coins belonging to someone else. If a
 signature is invalid, the transaction is considered invalid too and, 
thus, cannot be added to the blockchain.</p>
<p>We have all the pieces to implement transactions signing, except one 
thing: data to sign. What parts of a transaction are actually signed? Or
 a transaction is signed as a whole? Choosing data to sign is quite 
important. The thing is that data to be signed must contain information 
that identifies the data in a unique way. For example, it makes no sense
 signing just output values because such signature won’t consider the 
sender and the recipient.</p>
<p>Considering that transactions unlock previous outputs, redistribute 
their values, and lock new outputs, the following data must be signed:</p>
<ol>
<li>Public key hashes stored in unlocked outputs. This identifies “sender” of a transaction.</li>
<li>Public key hashes stored in new, locked, outputs. This identifies “recipient” of a transaction.</li>
<li>Values of new outputs.</li>
</ol>
<blockquote>
<p>In Bitcoin, locking/unlocking logic is stored in scripts, which are stored in <code>ScriptSig</code> and <code>ScriptPubKey</code>
 fields of inputs and outputs, respectively. Since Bitcoins allows 
different types of such scripts, it signs the whole content of <code>ScriptPubKey</code>.</p>
</blockquote>
<p>As you can see, we don’t need to sign the public keys stored in 
inputs. Because of this, in Bitcoin, it’s not a transaction that’s 
signed, but its trimmed copy with inputs storing <code>ScriptPubKey</code> from referenced outputs.</p>
<blockquote>
<p>A detailed process of getting a trimmed transaction copy is described <a href="https://en.bitcoin.it/wiki/File:Bitcoin_OpCheckSig_InDetail.png">here</a>. It’s likely to be outdated, but I didn’t manage to find a more reliable source of information.</p>
</blockquote>
<p>Ok, it looks complicated, so let’s start coding. We’ll start with the <code>Sign</code> method:</p>
<div class="highlight"><pre tabindex="0" class="chroma language-go"><code class=" language-go" data-lang="go"><span class="token keyword">func</span> <span class="token punctuation">(</span>tx <span class="token operator">*</span>Transaction<span class="token punctuation">)</span> <span class="token function">Sign</span><span class="token punctuation">(</span>privKey ecdsa<span class="token punctuation">.</span>PrivateKey<span class="token punctuation">,</span> prevTXs <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>Transaction<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> tx<span class="token punctuation">.</span><span class="token function">IsCoinbase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>

	txCopy <span class="token operator">:=</span> tx<span class="token punctuation">.</span><span class="token function">TrimmedCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">for</span> inID<span class="token punctuation">,</span> vin <span class="token operator">:=</span> <span class="token keyword">range</span> txCopy<span class="token punctuation">.</span>Vin <span class="token punctuation">{</span>
		prevTx <span class="token operator">:=</span> prevTXs<span class="token punctuation">[</span>hex<span class="token punctuation">.</span><span class="token function">EncodeToString</span><span class="token punctuation">(</span>vin<span class="token punctuation">.</span>Txid<span class="token punctuation">)</span><span class="token punctuation">]</span>
		txCopy<span class="token punctuation">.</span>Vin<span class="token punctuation">[</span>inID<span class="token punctuation">]</span><span class="token punctuation">.</span>Signature <span class="token operator">=</span> <span class="token boolean">nil</span>
		txCopy<span class="token punctuation">.</span>Vin<span class="token punctuation">[</span>inID<span class="token punctuation">]</span><span class="token punctuation">.</span>PubKey <span class="token operator">=</span> prevTx<span class="token punctuation">.</span>Vout<span class="token punctuation">[</span>vin<span class="token punctuation">.</span>Vout<span class="token punctuation">]</span><span class="token punctuation">.</span>PubKeyHash
		txCopy<span class="token punctuation">.</span>ID <span class="token operator">=</span> txCopy<span class="token punctuation">.</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		txCopy<span class="token punctuation">.</span>Vin<span class="token punctuation">[</span>inID<span class="token punctuation">]</span><span class="token punctuation">.</span>PubKey <span class="token operator">=</span> <span class="token boolean">nil</span>

		r<span class="token punctuation">,</span> s<span class="token punctuation">,</span> err <span class="token operator">:=</span> ecdsa<span class="token punctuation">.</span><span class="token function">Sign</span><span class="token punctuation">(</span>rand<span class="token punctuation">.</span>Reader<span class="token punctuation">,</span> <span class="token operator">&amp;</span>privKey<span class="token punctuation">,</span> txCopy<span class="token punctuation">.</span>ID<span class="token punctuation">)</span>
		signature <span class="token operator">:=</span> <span class="token function">append</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span><span class="token function">Bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">Bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">)</span>

		tx<span class="token punctuation">.</span>Vin<span class="token punctuation">[</span>inID<span class="token punctuation">]</span><span class="token punctuation">.</span>Signature <span class="token operator">=</span> signature
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>The method takes a private key and a map of 
previous transactions. As mentioned above, in order to sign a 
transaction, we need to access the outputs referenced in the inputs of 
the transaction, thus we need the transactions that store these outputs.</p>
<p>Let’s review this method step by step:</p>
<div class="highlight"><pre tabindex="0" class="chroma language-go"><code class=" language-go" data-lang="go"><span class="token keyword">if</span> tx<span class="token punctuation">.</span><span class="token function">IsCoinbase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Coinbase transactions are not signed because there are no real inputs in them.</p>
<div class="highlight"><pre tabindex="0" class="chroma language-go"><code class=" language-go" data-lang="go">txCopy <span class="token operator">:=</span> tx<span class="token punctuation">.</span><span class="token function">TrimmedCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>A trimmed copy will be signed, not a full transaction:</p>
<div class="highlight"><pre tabindex="0" class="chroma language-go"><code class=" language-go" data-lang="go"><span class="token keyword">func</span> <span class="token punctuation">(</span>tx <span class="token operator">*</span>Transaction<span class="token punctuation">)</span> <span class="token function">TrimmedCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Transaction <span class="token punctuation">{</span>
	<span class="token keyword">var</span> inputs <span class="token punctuation">[</span><span class="token punctuation">]</span>TXInput
	<span class="token keyword">var</span> outputs <span class="token punctuation">[</span><span class="token punctuation">]</span>TXOutput

	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> vin <span class="token operator">:=</span> <span class="token keyword">range</span> tx<span class="token punctuation">.</span>Vin <span class="token punctuation">{</span>
		inputs <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>inputs<span class="token punctuation">,</span> TXInput<span class="token punctuation">{</span>vin<span class="token punctuation">.</span>Txid<span class="token punctuation">,</span> vin<span class="token punctuation">.</span>Vout<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> vout <span class="token operator">:=</span> <span class="token keyword">range</span> tx<span class="token punctuation">.</span>Vout <span class="token punctuation">{</span>
		outputs <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> TXOutput<span class="token punctuation">{</span>vout<span class="token punctuation">.</span>Value<span class="token punctuation">,</span> vout<span class="token punctuation">.</span>PubKeyHash<span class="token punctuation">}</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	txCopy <span class="token operator">:=</span> Transaction<span class="token punctuation">{</span>tx<span class="token punctuation">.</span>ID<span class="token punctuation">,</span> inputs<span class="token punctuation">,</span> outputs<span class="token punctuation">}</span>

	<span class="token keyword">return</span> txCopy
<span class="token punctuation">}</span>
</code></pre></div><p>The copy will include all the inputs and outputs, but <code>TXInput.Signature</code> and <code>TXInput.PubKey</code> are set to nil.</p>
<p>Next, we iterate over each input in the copy:</p>
<div class="highlight"><pre tabindex="0" class="chroma language-go"><code class=" language-go" data-lang="go"><span class="token keyword">for</span> inID<span class="token punctuation">,</span> vin <span class="token operator">:=</span> <span class="token keyword">range</span> txCopy<span class="token punctuation">.</span>Vin <span class="token punctuation">{</span>
	prevTx <span class="token operator">:=</span> prevTXs<span class="token punctuation">[</span>hex<span class="token punctuation">.</span><span class="token function">EncodeToString</span><span class="token punctuation">(</span>vin<span class="token punctuation">.</span>Txid<span class="token punctuation">)</span><span class="token punctuation">]</span>
	txCopy<span class="token punctuation">.</span>Vin<span class="token punctuation">[</span>inID<span class="token punctuation">]</span><span class="token punctuation">.</span>Signature <span class="token operator">=</span> <span class="token boolean">nil</span>
	txCopy<span class="token punctuation">.</span>Vin<span class="token punctuation">[</span>inID<span class="token punctuation">]</span><span class="token punctuation">.</span>PubKey <span class="token operator">=</span> prevTx<span class="token punctuation">.</span>Vout<span class="token punctuation">[</span>vin<span class="token punctuation">.</span>Vout<span class="token punctuation">]</span><span class="token punctuation">.</span>PubKeyHash
</code></pre></div><p>In each input, <code>Signature</code> is set to <code>nil</code> (just a double-check) and <code>PubKey</code> is set to the <code>PubKeyHash</code> of the referenced output. At this moment, all transactions but the current one are “empty”, i.e. their <code>Signature</code> and <code>PubKey</code> fields are set to nil. Thus, <strong>inputs are signed separately</strong>,
 although this is not necessary for our application, but Bitcoin allows 
transactions to contain inputs referencing different addresses.</p>
<div class="highlight"><pre tabindex="0" class="chroma language-go"><code class=" language-go" data-lang="go">	txCopy<span class="token punctuation">.</span>ID <span class="token operator">=</span> txCopy<span class="token punctuation">.</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	txCopy<span class="token punctuation">.</span>Vin<span class="token punctuation">[</span>inID<span class="token punctuation">]</span><span class="token punctuation">.</span>PubKey <span class="token operator">=</span> <span class="token boolean">nil</span>
</code></pre></div><p>The <code>Hash</code> method serializes the 
transaction and hashes it with the SHA-256 algorithm. The resulted hash 
is the data we’re going to sign. After getting the hash we should reset 
the <code>PubKey</code> field, so it doesn’t affect further iterations.</p>
<p>Now, the central piece:</p>
<div class="highlight"><pre tabindex="0" class="chroma language-go"><code class=" language-go" data-lang="go">	r<span class="token punctuation">,</span> s<span class="token punctuation">,</span> err <span class="token operator">:=</span> ecdsa<span class="token punctuation">.</span><span class="token function">Sign</span><span class="token punctuation">(</span>rand<span class="token punctuation">.</span>Reader<span class="token punctuation">,</span> <span class="token operator">&amp;</span>privKey<span class="token punctuation">,</span> txCopy<span class="token punctuation">.</span>ID<span class="token punctuation">)</span>
	signature <span class="token operator">:=</span> <span class="token function">append</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span><span class="token function">Bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">Bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">)</span>

	tx<span class="token punctuation">.</span>Vin<span class="token punctuation">[</span>inID<span class="token punctuation">]</span><span class="token punctuation">.</span>Signature <span class="token operator">=</span> signature
</code></pre></div><p>We sign <code>txCopy.ID</code> with <code>privKey</code>. An ECDSA signature is a pair of numbers, which we concatenate and store in the input’s <code>Signature</code> field.</p>
<p>Now, the verification function:</p>
<div class="highlight"><pre tabindex="0" class="chroma language-go"><code class=" language-go" data-lang="go"><span class="token keyword">func</span> <span class="token punctuation">(</span>tx <span class="token operator">*</span>Transaction<span class="token punctuation">)</span> <span class="token function">Verify</span><span class="token punctuation">(</span>prevTXs <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>Transaction<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
	txCopy <span class="token operator">:=</span> tx<span class="token punctuation">.</span><span class="token function">TrimmedCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	curve <span class="token operator">:=</span> elliptic<span class="token punctuation">.</span><span class="token function">P256</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">for</span> inID<span class="token punctuation">,</span> vin <span class="token operator">:=</span> <span class="token keyword">range</span> tx<span class="token punctuation">.</span>Vin <span class="token punctuation">{</span>
		prevTx <span class="token operator">:=</span> prevTXs<span class="token punctuation">[</span>hex<span class="token punctuation">.</span><span class="token function">EncodeToString</span><span class="token punctuation">(</span>vin<span class="token punctuation">.</span>Txid<span class="token punctuation">)</span><span class="token punctuation">]</span>
		txCopy<span class="token punctuation">.</span>Vin<span class="token punctuation">[</span>inID<span class="token punctuation">]</span><span class="token punctuation">.</span>Signature <span class="token operator">=</span> <span class="token boolean">nil</span>
		txCopy<span class="token punctuation">.</span>Vin<span class="token punctuation">[</span>inID<span class="token punctuation">]</span><span class="token punctuation">.</span>PubKey <span class="token operator">=</span> prevTx<span class="token punctuation">.</span>Vout<span class="token punctuation">[</span>vin<span class="token punctuation">.</span>Vout<span class="token punctuation">]</span><span class="token punctuation">.</span>PubKeyHash
		txCopy<span class="token punctuation">.</span>ID <span class="token operator">=</span> txCopy<span class="token punctuation">.</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		txCopy<span class="token punctuation">.</span>Vin<span class="token punctuation">[</span>inID<span class="token punctuation">]</span><span class="token punctuation">.</span>PubKey <span class="token operator">=</span> <span class="token boolean">nil</span>

		r <span class="token operator">:=</span> big<span class="token punctuation">.</span>Int<span class="token punctuation">{</span><span class="token punctuation">}</span>
		s <span class="token operator">:=</span> big<span class="token punctuation">.</span>Int<span class="token punctuation">{</span><span class="token punctuation">}</span>
		sigLen <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>vin<span class="token punctuation">.</span>Signature<span class="token punctuation">)</span>
		r<span class="token punctuation">.</span><span class="token function">SetBytes</span><span class="token punctuation">(</span>vin<span class="token punctuation">.</span>Signature<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">(</span>sigLen <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
		s<span class="token punctuation">.</span><span class="token function">SetBytes</span><span class="token punctuation">(</span>vin<span class="token punctuation">.</span>Signature<span class="token punctuation">[</span><span class="token punctuation">(</span>sigLen <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

		x <span class="token operator">:=</span> big<span class="token punctuation">.</span>Int<span class="token punctuation">{</span><span class="token punctuation">}</span>
		y <span class="token operator">:=</span> big<span class="token punctuation">.</span>Int<span class="token punctuation">{</span><span class="token punctuation">}</span>
		keyLen <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>vin<span class="token punctuation">.</span>PubKey<span class="token punctuation">)</span>
		x<span class="token punctuation">.</span><span class="token function">SetBytes</span><span class="token punctuation">(</span>vin<span class="token punctuation">.</span>PubKey<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">(</span>keyLen <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
		y<span class="token punctuation">.</span><span class="token function">SetBytes</span><span class="token punctuation">(</span>vin<span class="token punctuation">.</span>PubKey<span class="token punctuation">[</span><span class="token punctuation">(</span>keyLen <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

		rawPubKey <span class="token operator">:=</span> ecdsa<span class="token punctuation">.</span>PublicKey<span class="token punctuation">{</span>curve<span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">}</span>
		<span class="token keyword">if</span> ecdsa<span class="token punctuation">.</span><span class="token function">Verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rawPubKey<span class="token punctuation">,</span> txCopy<span class="token punctuation">.</span>ID<span class="token punctuation">,</span> <span class="token operator">&amp;</span>r<span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">false</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token boolean">false</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>
</code></pre></div><p>The method is quite straightforward. First, we need the same transaction copy:</p>
<div class="highlight"><pre tabindex="0" class="chroma language-go"><code class=" language-go" data-lang="go">txCopy <span class="token operator">:=</span> tx<span class="token punctuation">.</span><span class="token function">TrimmedCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>Next, we’ll need the same curve that is used to generate key pairs:</p>
<div class="highlight"><pre tabindex="0" class="chroma language-go"><code class=" language-go" data-lang="go">curve <span class="token operator">:=</span> elliptic<span class="token punctuation">.</span><span class="token function">P256</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>Next, we check signature in each input:</p>
<div class="highlight"><pre tabindex="0" class="chroma language-go"><code class=" language-go" data-lang="go"><span class="token keyword">for</span> inID<span class="token punctuation">,</span> vin <span class="token operator">:=</span> <span class="token keyword">range</span> tx<span class="token punctuation">.</span>Vin <span class="token punctuation">{</span>
	prevTx <span class="token operator">:=</span> prevTXs<span class="token punctuation">[</span>hex<span class="token punctuation">.</span><span class="token function">EncodeToString</span><span class="token punctuation">(</span>vin<span class="token punctuation">.</span>Txid<span class="token punctuation">)</span><span class="token punctuation">]</span>
	txCopy<span class="token punctuation">.</span>Vin<span class="token punctuation">[</span>inID<span class="token punctuation">]</span><span class="token punctuation">.</span>Signature <span class="token operator">=</span> <span class="token boolean">nil</span>
	txCopy<span class="token punctuation">.</span>Vin<span class="token punctuation">[</span>inID<span class="token punctuation">]</span><span class="token punctuation">.</span>PubKey <span class="token operator">=</span> prevTx<span class="token punctuation">.</span>Vout<span class="token punctuation">[</span>vin<span class="token punctuation">.</span>Vout<span class="token punctuation">]</span><span class="token punctuation">.</span>PubKeyHash
	txCopy<span class="token punctuation">.</span>ID <span class="token operator">=</span> txCopy<span class="token punctuation">.</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	txCopy<span class="token punctuation">.</span>Vin<span class="token punctuation">[</span>inID<span class="token punctuation">]</span><span class="token punctuation">.</span>PubKey <span class="token operator">=</span> <span class="token boolean">nil</span>
</code></pre></div><p>This piece is identical to the one in the <code>Sign</code> method, because during verification we need the same data what was signed.</p>
<div class="highlight"><pre tabindex="0" class="chroma language-go"><code class=" language-go" data-lang="go">	r <span class="token operator">:=</span> big<span class="token punctuation">.</span>Int<span class="token punctuation">{</span><span class="token punctuation">}</span>
	s <span class="token operator">:=</span> big<span class="token punctuation">.</span>Int<span class="token punctuation">{</span><span class="token punctuation">}</span>
	sigLen <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>vin<span class="token punctuation">.</span>Signature<span class="token punctuation">)</span>
	r<span class="token punctuation">.</span><span class="token function">SetBytes</span><span class="token punctuation">(</span>vin<span class="token punctuation">.</span>Signature<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">(</span>sigLen <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
	s<span class="token punctuation">.</span><span class="token function">SetBytes</span><span class="token punctuation">(</span>vin<span class="token punctuation">.</span>Signature<span class="token punctuation">[</span><span class="token punctuation">(</span>sigLen <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

	x <span class="token operator">:=</span> big<span class="token punctuation">.</span>Int<span class="token punctuation">{</span><span class="token punctuation">}</span>
	y <span class="token operator">:=</span> big<span class="token punctuation">.</span>Int<span class="token punctuation">{</span><span class="token punctuation">}</span>
	keyLen <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>vin<span class="token punctuation">.</span>PubKey<span class="token punctuation">)</span>
	x<span class="token punctuation">.</span><span class="token function">SetBytes</span><span class="token punctuation">(</span>vin<span class="token punctuation">.</span>PubKey<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">(</span>keyLen <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
	y<span class="token punctuation">.</span><span class="token function">SetBytes</span><span class="token punctuation">(</span>vin<span class="token punctuation">.</span>PubKey<span class="token punctuation">[</span><span class="token punctuation">(</span>keyLen <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><p>Here we unpack values stored in <code>TXInput.Signature</code> and <code>TXInput.PubKey</code>,
 since a signature is a pair of numbers and a public key is a pair of 
coordinates. We concatenated them earlier for storing, and now we need 
to unpack them to use in <code>crypto/ecdsa</code> functions.</p>
<div class="highlight"><pre tabindex="0" class="chroma language-go"><code class=" language-go" data-lang="go">	rawPubKey <span class="token operator">:=</span> ecdsa<span class="token punctuation">.</span>PublicKey<span class="token punctuation">{</span>curve<span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">}</span>
	<span class="token keyword">if</span> ecdsa<span class="token punctuation">.</span><span class="token function">Verify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rawPubKey<span class="token punctuation">,</span> txCopy<span class="token punctuation">.</span>ID<span class="token punctuation">,</span> <span class="token operator">&amp;</span>r<span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">false</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token boolean">false</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">return</span> <span class="token boolean">true</span>
</code></pre></div><p>Here it is: we create an <code>ecdsa.PublicKey</code> using the public key extracted from the input and execute <code>ecdsa.Verify</code>
 passing the signature extracted from the input. If all inputs are 
verified, return true; if at least one input fails verification, return 
false.</p>
<p>Now, we need a function to obtain previous transactions. Since this 
requires interaction with the blockchain, we’ll make it a method of <code>Blockchain</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma language-go"><code class=" language-go" data-lang="go"><span class="token keyword">func</span> <span class="token punctuation">(</span>bc <span class="token operator">*</span>Blockchain<span class="token punctuation">)</span> <span class="token function">FindTransaction</span><span class="token punctuation">(</span>ID <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Transaction<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	bci <span class="token operator">:=</span> bc<span class="token punctuation">.</span><span class="token function">Iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">for</span> <span class="token punctuation">{</span>
		block <span class="token operator">:=</span> bci<span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

		<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> tx <span class="token operator">:=</span> <span class="token keyword">range</span> block<span class="token punctuation">.</span>Transactions <span class="token punctuation">{</span>
			<span class="token keyword">if</span> bytes<span class="token punctuation">.</span><span class="token function">Compare</span><span class="token punctuation">(</span>tx<span class="token punctuation">.</span>ID<span class="token punctuation">,</span> ID<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
				<span class="token keyword">return</span> <span class="token operator">*</span>tx<span class="token punctuation">,</span> <span class="token boolean">nil</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>block<span class="token punctuation">.</span>PrevBlockHash<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> Transaction<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"Transaction is not found"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>bc <span class="token operator">*</span>Blockchain<span class="token punctuation">)</span> <span class="token function">SignTransaction</span><span class="token punctuation">(</span>tx <span class="token operator">*</span>Transaction<span class="token punctuation">,</span> privKey ecdsa<span class="token punctuation">.</span>PrivateKey<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	prevTXs <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>Transaction<span class="token punctuation">)</span>

	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> vin <span class="token operator">:=</span> <span class="token keyword">range</span> tx<span class="token punctuation">.</span>Vin <span class="token punctuation">{</span>
		prevTX<span class="token punctuation">,</span> err <span class="token operator">:=</span> bc<span class="token punctuation">.</span><span class="token function">FindTransaction</span><span class="token punctuation">(</span>vin<span class="token punctuation">.</span>Txid<span class="token punctuation">)</span>
		prevTXs<span class="token punctuation">[</span>hex<span class="token punctuation">.</span><span class="token function">EncodeToString</span><span class="token punctuation">(</span>prevTX<span class="token punctuation">.</span>ID<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> prevTX
	<span class="token punctuation">}</span>

	tx<span class="token punctuation">.</span><span class="token function">Sign</span><span class="token punctuation">(</span>privKey<span class="token punctuation">,</span> prevTXs<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>bc <span class="token operator">*</span>Blockchain<span class="token punctuation">)</span> <span class="token function">VerifyTransaction</span><span class="token punctuation">(</span>tx <span class="token operator">*</span>Transaction<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
	prevTXs <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>Transaction<span class="token punctuation">)</span>

	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> vin <span class="token operator">:=</span> <span class="token keyword">range</span> tx<span class="token punctuation">.</span>Vin <span class="token punctuation">{</span>
		prevTX<span class="token punctuation">,</span> err <span class="token operator">:=</span> bc<span class="token punctuation">.</span><span class="token function">FindTransaction</span><span class="token punctuation">(</span>vin<span class="token punctuation">.</span>Txid<span class="token punctuation">)</span>
		prevTXs<span class="token punctuation">[</span>hex<span class="token punctuation">.</span><span class="token function">EncodeToString</span><span class="token punctuation">(</span>prevTX<span class="token punctuation">.</span>ID<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> prevTX
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> tx<span class="token punctuation">.</span><span class="token function">Verify</span><span class="token punctuation">(</span>prevTXs<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>These functions are simple: <code>FindTransaction</code> finds a transaction by ID (this requires iterating over all the blocks in the blockchain); <code>SignTransaction</code> takes a transaction, finds transactions it references, and signs it; <code>VerifyTransaction</code> does the same, but verifies the transaction instead.</p>
<p>Now, we need to actually sign and verify transactions. Signing happens in the <code>NewUTXOTransaction</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma language-go"><code class=" language-go" data-lang="go"><span class="token keyword">func</span> <span class="token function">NewUTXOTransaction</span><span class="token punctuation">(</span>from<span class="token punctuation">,</span> to <span class="token builtin">string</span><span class="token punctuation">,</span> amount <span class="token builtin">int</span><span class="token punctuation">,</span> bc <span class="token operator">*</span>Blockchain<span class="token punctuation">)</span> <span class="token operator">*</span>Transaction <span class="token punctuation">{</span>
	<span class="token operator">...</span>

	tx <span class="token operator">:=</span> Transaction<span class="token punctuation">{</span><span class="token boolean">nil</span><span class="token punctuation">,</span> inputs<span class="token punctuation">,</span> outputs<span class="token punctuation">}</span>
	tx<span class="token punctuation">.</span>ID <span class="token operator">=</span> tx<span class="token punctuation">.</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	bc<span class="token punctuation">.</span><span class="token function">SignTransaction</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tx<span class="token punctuation">,</span> wallet<span class="token punctuation">.</span>PrivateKey<span class="token punctuation">)</span>

	<span class="token keyword">return</span> <span class="token operator">&amp;</span>tx
<span class="token punctuation">}</span>
</code></pre></div><p>Verification happens before a transaction is put into a block:</p>
<div class="highlight"><pre tabindex="0" class="chroma language-go"><code class=" language-go" data-lang="go"><span class="token keyword">func</span> <span class="token punctuation">(</span>bc <span class="token operator">*</span>Blockchain<span class="token punctuation">)</span> <span class="token function">MineBlock</span><span class="token punctuation">(</span>transactions <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Transaction<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> lastHash <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>

	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> tx <span class="token operator">:=</span> <span class="token keyword">range</span> transactions <span class="token punctuation">{</span>
		<span class="token keyword">if</span> bc<span class="token punctuation">.</span><span class="token function">VerifyTransaction</span><span class="token punctuation">(</span>tx<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token boolean">true</span> <span class="token punctuation">{</span>
			log<span class="token punctuation">.</span><span class="token function">Panic</span><span class="token punctuation">(</span><span class="token string">"ERROR: Invalid transaction"</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>And that’s it! Let’s check everything one more time:</p>
<div class="highlight"><pre tabindex="0" class="chroma language-shell"><code class=" language-shell" data-lang="shell">$ blockchain_go createwallet
Your new address: 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR

$ blockchain_go createwallet
Your new address: 1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab

$ blockchain_go createblockchain -address 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR
000000122348da06c19e5c513710340f4c307d884385da948a205655c6a9d008

Done<span class="token operator">!</span>

$ blockchain_go send -from 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR -to 1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab -amount <span class="token number">6</span>
0000000f3dbb0ab6d56c4e4b9f7479afe8d5a5dad4d2a8823345a1a16cf3347b

Success<span class="token operator">!</span>

$ blockchain_go getbalance -address 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR
Balance of <span class="token string">'1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR'</span><span class="token builtin class-name">:</span> <span class="token number">4</span>

$ blockchain_go getbalance -address 1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab
Balance of <span class="token string">'1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab'</span><span class="token builtin class-name">:</span> <span class="token number">6</span>
</code></pre></div><p>Nothing is broken. Awesome!</p>
<p>Let’s also comment out the <code>bc.SignTransaction(&amp;tx, wallet.PrivateKey)</code> call in <code>NewUTXOTransaction</code> to ensure that unsigned transactions cannot be mined:</p>
<div class="highlight"><pre tabindex="0" class="chroma language-go"><code class=" language-go" data-lang="go"><span class="token keyword">func</span> <span class="token function">NewUTXOTransaction</span><span class="token punctuation">(</span>from<span class="token punctuation">,</span> to <span class="token builtin">string</span><span class="token punctuation">,</span> amount <span class="token builtin">int</span><span class="token punctuation">,</span> bc <span class="token operator">*</span>Blockchain<span class="token punctuation">)</span> <span class="token operator">*</span>Transaction <span class="token punctuation">{</span>
   <span class="token operator">...</span>
	tx <span class="token operator">:=</span> Transaction<span class="token punctuation">{</span><span class="token boolean">nil</span><span class="token punctuation">,</span> inputs<span class="token punctuation">,</span> outputs<span class="token punctuation">}</span>
	tx<span class="token punctuation">.</span>ID <span class="token operator">=</span> tx<span class="token punctuation">.</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">// bc.SignTransaction(&amp;tx, wallet.PrivateKey)</span>

	<span class="token keyword">return</span> <span class="token operator">&amp;</span>tx
<span class="token punctuation">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" class="chroma language-shell"><code class=" language-shell" data-lang="shell">$ go <span class="token function">install</span>
$ blockchain_go send -from 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR -to 1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab -amount <span class="token number">1</span>
<span class="token number">2017</span>/09/12 <span class="token number">16</span>:28:15 ERROR: Invalid transaction
</code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>It’s really awesome that we’ve got so far and implemented so many key
 features of Bitcoin! We’ve implemented almost everything outside 
networking, and in the next part, we’ll finish transactions.</p>
<p>Links:</p>
<ol>
<li><a href="https://github.com/Jeiwan/blockchain_go/tree/part_5">Full source codes</a></li>
<li><a href="https://en.wikipedia.org/wiki/Public-key_cryptography">Public-key cryptography</a></li>
<li><a href="https://en.wikipedia.org/wiki/Digital_signature">Digital signatures</a></li>
<li><a href="https://en.wikipedia.org/wiki/Elliptic_curve">Elliptic curve</a></li>
<li><a href="https://en.wikipedia.org/wiki/Elliptic_curve_cryptography">Elliptic curve cryptography</a></li>
<li><a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm">ECDSA</a></li>
<li><a href="https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses">Technical background of Bitcoin addresses</a></li>
<li><a href="https://en.bitcoin.it/wiki/Address">Address</a></li>
<li><a href="https://en.bitcoin.it/wiki/Base58Check_encoding">Base58</a></li>
<li><a href="http://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">A gentle introduction to elliptic curve cryptography</a></li>
</ol>


</article>

<hr>
<br>






      <footer class="site-footer">
        <span itemscope="" itemtype="http://schema.org/Person">
          <link itemprop="url" href="https://jeiwan.net/">

          Author:
          <span itemprop="name">Ivan Kuznetsov</span>

          <br>

          Get in touch:

          <a itemprop="sameAs" href="mailto:me@jeiwan.ru" target="_blank">E-mail</a>

          <a itemprop="sameAs" href="https://t.me/jeiwan" title="Telegram" target="_blank">Telegram</a>

          <a itemprop="sameAs" href="https://twitter.com/jeiwan7" title="Twitter" target="_blank">Twitter</a>

          <a itemprop="sameAs" href="https://github.com/jeiwan" title="GitHub" target="_blank">GitHub</a>

          
        </span>

        <br><br>

        <div style="text-align:center">
          <small>
            <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="Building%20Blockchain%20in%20Go.%20Part%205%20Addresses%20-%20Going%20the%20distance_files/88x31.png"></a><br>Content of this site is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
          </small>
        </div>

        
      </footer>
    </div>

  

    <script src="Building%20Blockchain%20in%20Go.%20Part%205%20Addresses%20-%20Going%20the%20distance_files/prism.js"></script>

  

</body></html>